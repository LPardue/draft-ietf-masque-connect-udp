{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2020-10-15T00:58:54.958727+00:00",
  "repo": "ietf-wg-masque/draft-ietf-masque-connect-udp",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWU2ODc2OTQ1NTE=",
      "title": "CONNECT-UDP and multiple intermediaries",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/1",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue reported by @martinthomson on [2020-04-16](https://github.com/DavidSchinazi/masque-drafts/issues/21#issue-601716642)\r\n\r\n> Note that when multiple proxies are involved in a CONNECT-UDP request, all the HTTP connections along the path need to be using HTTP/3 [H3] or later in order for UDP payloads to be sent over QUIC DATAGRAM frames.\r\n\r\nHow is this true? The first proxy should convert the stream of encapsulated UDP datagrams into actual UDP datagrams. That means that the second proxy won't see these as part of the connection.\r\n\r\nThis is only an issue if the proxy wants to pass the DATAGRAM frames on to the next proxy. But that's not what is being asked of it, if it does that, it does so on its own recognizance. (I should add: if it chooses to forward to a next hop that uses h2, then it can take the DATAGRAM frames and stuff them into the request stream.)",
      "createdAt": "2020-08-28T04:03:10Z",
      "updatedAt": "2020-08-28T04:04:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Reply by me on 2020-04-17:\r\n\r\nIt's definitely possible for a chain of proxies to use heterogeneous encodings for their UDP packets, by which I mean if the topology is `Client - ProxyA - ProxyB - Destination` then we could build this so that `Client - ProxyA` uses DATAGRAM frames whereas `ProxyA - ProxyB` uses the stream encoding with HTTP/2.\r\n\r\nI don't think the benefits outweigh the added complexity, so the current design is all-or-nothing: if all legs supports H3-DATAGRAM then it can be used, otherwise fallback to the stream encoding.",
          "createdAt": "2020-08-28T04:03:51Z",
          "updatedAt": "2020-08-28T04:03:51Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Reply by @martinthomson on 2020-04-19:\r\n\r\nI'm not really clear on how you think that might work. If Client and Proxy A negotiate the use of DATAGRAM, does this depend on Proxy A verifying first that Proxy B also supports DATAGRAM? How do you ensure that the identifiers are comprehensible to all parties?",
          "createdAt": "2020-08-28T04:04:13Z",
          "updatedAt": "2020-08-28T04:04:13Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "MDU6SXNzdWU2ODc2OTUzMjM=",
      "title": "CONNECT-UDP request body",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/2",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue reported by @martinthomson on [2020-04-16](https://github.com/DavidSchinazi/masque-drafts/issues/22):\r\n\r\n>    A payload within a CONNECT-UDP request message has no defined semantics; a CONNECT-UDP request with a non-empty payload is malformed.\r\n\r\nI think that this text is out of sync with the rest of the doc.  The payload is used to carry UDP packets, even when you use DATAGRAM frames.",
      "createdAt": "2020-08-28T04:05:37Z",
      "updatedAt": "2020-08-28T04:06:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Reply from me on 2020-04-17:\r\n\r\nI think this is just a question of semantics. CONNECT takes over the stream, and therefore the contents of that stream are not considered to be the payload of the HTTP response.\r\n\r\nFrom [RFC 7231 s4.3.6](https://tools.ietf.org/html/rfc7231#section-4.3.6):\r\n>   A payload within a CONNECT request message has no defined semantics;\r\n>   sending a payload body on a CONNECT request might cause some existing\r\n>   implementations to reject the request.",
          "createdAt": "2020-08-28T04:06:03Z",
          "updatedAt": "2020-08-28T04:06:03Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU2ODc2OTU5NzU=",
      "title": "Datagram-Flow-Id is hop-by-hop",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/3",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue reported by @martinthomson on [2020-04-16](https://github.com/DavidSchinazi/masque-drafts/issues/23):\r\n\r\nThat is *probably* OK for something with CONNECT-like semantics, but we did explicitly choose to disable hop-by-hop fields in HTTP/2.",
      "createdAt": "2020-08-28T04:07:34Z",
      "updatedAt": "2020-08-28T04:08:43Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment from @martinthomson on 2020-04-16:\r\n\r\nI just realized that, because this is a new method and will be treated as such by intermediaries that don't understand it, they will pass Datagram-Flow-Id along. That is very much a bad thing as the server on the next hop might have negotiated H3_DATAGRAM with the intermediary for other reasons. If the next hop understands the setting, it might send responses in datagrams that will then be dropped by the intermediary (because it doesn't understand Datagram-Flow-Id).\r\n\r\nThat is, on a chain of entities from client A, intermediary B, and intermediary C, if all of them support H3_DATAGRAM, but B does not support Datagram-Flow-Id or CONNECT-UDP, this ultimately results in packets being sent on the request stream for a while, then DATAGRAM frames being sent toward the intermediary and being dropped.",
          "createdAt": "2020-08-28T04:07:56Z",
          "updatedAt": "2020-08-28T04:07:56Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment from me on 2020-04-17:\r\n\r\nRegarding your first comment, I agree that this is somewhat of a hop-by-hop field. Do you have a proposal that achieves the same result without using a hop-by-hop field?\r\n\r\nRegarding your second comment, it's not possible for intermediaries to not understand this and still pass it along. If the intermediary doesn't know about this spec it'll respond with status code 405 \"Method Not Allowed\" instead of forwarding it.",
          "createdAt": "2020-08-28T04:08:11Z",
          "updatedAt": "2020-08-28T04:08:11Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment from @martinthomson on 2020-04-19:\r\n\r\nProxies aren't required to understand all methods, so why would it send a 405? I mean, some might because they want to police what methods they pass, but they are not required to do so.",
          "createdAt": "2020-08-28T04:08:26Z",
          "updatedAt": "2020-08-28T04:08:26Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment from me on 2020-07-24:\r\n\r\nSorry, I should have said 501 \"Not Implemented\", not 405.",
          "createdAt": "2020-08-28T04:08:43Z",
          "updatedAt": "2020-08-28T04:08:43Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU2ODc2OTY3OTg=",
      "title": "Flow duration",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/4",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue created by @martinthomson on [2020-04-16](https://github.com/DavidSchinazi/masque-drafts/issues/24):\r\n\r\nThe CONNECT-UDP proxy has to act a little like a NAT when it forwards UDP. It has to assign a source IP and port. Those probably need to be dedicated to the flow for its lifetime. However, UDP lacks the clear signals of TCP about connection termination, so we need a clear definition of what lifetime is.\r\n\r\nIt is perhaps reasonable to tie the lifetime of the allocation to the existence of the stream, but then the connection from the client might drop mid-flow; how long does the proxy need to avoid reusing that address?\r\n\r\nThe proxy might also decide that idleness is cause for dropping bindings. The client needs to know this because it will need to make new tunnels to continue communication if it goes idle for too long.",
      "createdAt": "2020-08-28T04:10:04Z",
      "updatedAt": "2020-08-28T18:11:57Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment from me on 2020-04-17:\r\n\r\nThe intent was to have the lifetime of the UDP socket be tied to the existence of the CONNECT-UDP stream. But I agree that we should add text indicating that a server MAY want to garbage collect these after idle periods, and in that case it MUST close the corresponding stream to inform the client.",
          "createdAt": "2020-08-28T04:10:18Z",
          "updatedAt": "2020-08-28T04:10:18Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "An interesting extension: retain the binding for N seconds after the connection to the proxy drops and allow the client to rebind to that.  That allows for session continuity across transient connection failures for protocols that aren't QUIC (which are less vulnerable to that).",
          "createdAt": "2020-08-28T06:50:26Z",
          "updatedAt": "2020-08-28T06:50:26Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "That's a good idea. I could totally imagine an extension where the proxy tells the client the outgoing port it used in its CONNECT-UDP reply, and then the client is allowed to ask for a preferred port when requesting CONNECT-UDP. This could be achieved via HTTP request/response headers.",
          "createdAt": "2020-08-28T18:11:56Z",
          "updatedAt": "2020-08-28T18:11:56Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU2ODc2OTc0MDY=",
      "title": "Address mapping and return flow routing",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/5",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue created by @martinthomson on [2020-04-16](https://github.com/DavidSchinazi/masque-drafts/issues/25):\r\n\r\nThe design here would appear to permit the use of 'Address and Port-Dependent Mapping' as defined in [Section 4.1 of RFC 4787](https://tools.ietf.org/html/rfc4787#section-4.1).  However, that document strongly recommends that an 'Endpoint-Independent Mapping' is used so as to make UNSAF methods work.  This document should define those rules.\r\n\r\nRelated #4.",
      "createdAt": "2020-08-28T04:11:51Z",
      "updatedAt": "2020-08-28T04:12:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment from me on 2020-04-17:\r\n\r\nThe current text explicitly only allows \"Address and Port-Dependent Mapping\". It attempted to define those rules clearly in [section 6](https://tools.ietf.org/html/draft-schinazi-masque-connect-udp-00#section-6). UNSAF is currently considered out of scope and not supported. I'm not sure whether we want to increase the scope and add that complexity.",
          "createdAt": "2020-08-28T04:12:07Z",
          "updatedAt": "2020-08-28T04:12:07Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU2ODc2OTc4OTE=",
      "title": "Datagram-Flow-Id size limits",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/6",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue created by me on [2020-05-05](https://github.com/DavidSchinazi/masque-drafts/issues/26):\r\n\r\nAs of `connect-udp-00`, the `Datagram-Flow-Id` is [defined](https://tools.ietf.org/html/draft-schinazi-masque-connect-udp-00#section-5) as a [structured header of type sh-integer](https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-18#section-3.3.1). The max value for those is 10^15-1, but in theory flow IDs can go up to 2^62-1 (~4*10^18). We should either:\r\n- specify an alternate encoding, such as [an sh-binary byte sequence with specified endianness and maximum width](https://lists.w3.org/Archives/Public/ietf-http-wg/2020AprJun/0077.html)\r\n- note that values over 10^15-1 cannot be encoded and reaching that flow identifier should trigger closing the HTTP/3 connection and restarting it",
      "createdAt": "2020-08-28T04:13:18Z",
      "updatedAt": "2020-08-28T04:13:51Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment by @LPardue on 2020-05-05:\r\n\r\nI think the lower limit is ok. As a tangent, it might play nice with H2 fallback that uses stream IDs which are restricted to 2^31",
          "createdAt": "2020-08-28T04:13:50Z",
          "updatedAt": "2020-08-28T04:13:50Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWU2ODc2OTgzNzg=",
      "title": "CONNECT-UDP should communicate MTU",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/7",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue created by me on [2020-05-27](https://github.com/DavidSchinazi/masque-drafts/issues/27):\r\n\r\nCONNECT-UDP can be used across multiple proxy hops, and each of these hops can have a different MTU, so it could be useful for the client to be notified of the maximum DATAGRAM payload size that will make it across all the hops. This value could also change over time, so we could consider adding the ability to communicate that.",
      "createdAt": "2020-08-28T04:14:55Z",
      "updatedAt": "2020-08-28T04:15:11Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment from me on 2020-07-24:\r\n\r\nThis might be best handled by an extension to CONNECT-UDP, but keeping the issue open for now.",
          "createdAt": "2020-08-28T04:15:11Z",
          "updatedAt": "2020-08-28T04:15:11Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWU2ODc2OTg4Mjg=",
      "title": "CONNECT-UDP needs a request target URI",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/8",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue created by me on [2020-08-13](https://github.com/DavidSchinazi/masque-drafts/issues/29):\r\n\r\n[connect-udp-00 s3](https://tools.ietf.org/html/draft-schinazi-masque-connect-udp-00#section-3) mainly copied most of the CONNECT-UDP design from CONNECT, but than goes against some existing HTTP semantics. In particular, every HTTP method is supposed to use URIs to represent their request target (this was mentioned in [RFC 7231 s2](https://tools.ietf.org/html/rfc7231#section-2) and clarified in [draft-ietf-httpbis-semantics s6.1](https://tools.ietf.org/html/draft-ietf-httpbis-semantics-10#section-6.1)). CONNECT and OPTIONS are noted as existing exceptions, but new methods are not allowed exceptions, to allow intermediaries to proxy unknown methods. CONNECT-UDP only cares about the authority (host and port) portion of the URI, so we can easily encode that as an URI and mandate that the path MUST be \"/\" and the query MUST be empty. The main open question is what scheme to use. We could either reuse https, or register a new one.",
      "createdAt": "2020-08-28T04:16:15Z",
      "updatedAt": "2020-08-28T04:17:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment by @mirjak on 2020-08-14:\r\n\r\ndraft-ietf-httpbis-semantics notes CONNECT as a special case because it's only used for tunnelling by proxies and usually not even implemented by the origin server. This is the same scenario as we have for any new connect method and I think we should therefore follow the same semantics as already defined for CONNECT.",
          "createdAt": "2020-08-28T04:16:39Z",
          "updatedAt": "2020-08-28T04:16:39Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment by @MikeBishop on 2020-08-14:\r\n\r\n`udp://target-host:port`?",
          "createdAt": "2020-08-28T04:17:13Z",
          "updatedAt": "2020-08-28T04:17:13Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWU3MTc0OTQ2Nzc=",
      "title": "Just curious about \"0-length\" datagrams",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/9",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I just opened an issue on HTTP/3 datagram: https://github.com/DavidSchinazi/draft-h3-datagram/issues/8. There I suggest that receiving an H3 DATAGRAM frame with 0-length payload is an H3_FRAME_ERROR. \r\n\r\nBut after the flow ID \"is taken off\" the usable payload could be 0. I just wanted to check that a MASQUE proxy is fine to send 0-length UDP datagrams back and forth to an origin. That seems to be as-designed.",
      "createdAt": "2020-10-08T16:31:22Z",
      "updatedAt": "2020-10-08T17:14:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "From reading RFC 768 and 2675, as far as I can tell UDP datagrams with an empty payload are allowed, so I don't think we need to do anything in CONNECT-UDP, they'll just work.",
          "createdAt": "2020-10-08T16:39:55Z",
          "updatedAt": "2020-10-08T16:39:55Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "Yeah, there's a resolved issue on DATAGRAM where we explicitly wanted to allow this type of model, so I support keeping that.",
          "createdAt": "2020-10-08T17:14:24Z",
          "updatedAt": "2020-10-08T17:14:24Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWU3MTgzNjM1OTg=",
      "title": "UDP Pacing and Bursting Limits",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/10",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Who SHOULD have the responsibility for rate pacing and preventing bursts > ~10 packets? I can imagine a few models:\r\n\r\n- The client paces DATAGRAM frames on the tunneled UDP connection: this would allow QUIC implementations to not change, at least in this respect, when running over MASQUE. It also hopes the outer connection congestion control and/or the proxy logic will not cause these frames/datagrams to bunch up at their egresses.\r\n- The tunneled connection is as bursty as it wants to be, but the outer connection is paced: this has issues with heavy connection multiplexing, and the achievable rate on the outer connection may have no relationship to the rate end-to-end.\r\n- The proxy applies pacing and burst limits at its UDP egress: it's not clear how the proxy would obtain the correct pacing rate without an explicit signal. Of course some UDP apps have no notion of these concepts, so then what?\r\n\r\nAnyway, I'm suspicious that a wild west approach with no advice at all will lead to suboptimal outcomes, though it would not break interop (I wouldn't suggest any MUSTs here). Not saying anything would also preclude any explicit signaling, if that turns out to be beneficial.\r\n\r\nArguably, this is a thing for Magnus's draft, but I suspect that, as with MTU, there is much stronger consensus that pacing is A Necessary Thing than all the IP header fields in that draft. The proxy has no mechanism to flow control datagrams, so some sort of check on egress would be nice to avoid becoming a DoS vector.",
      "createdAt": "2020-10-09T19:07:07Z",
      "updatedAt": "2020-10-09T21:01:18Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that insufficient pacing can cause serious performance issues in applications that run over UDP. However, that's not a property of UDP proxying, that's a property of the end-to-end application protocol. I like the idea of adding text to recommend that the proxy does not introduce additional burstiness by queueing packets and then sending out a burst at a time. However, I'm not convinced that any explicit signaling for this would be beneficial, so I'd rather leave that top extensions.\r\n\r\nOn the topic of the DoS vector, I'd suggest filing a separate issue but I'll say that CONNECT had the benefit of not letting the client send more than a SYN until the end server has responded with a SYN-ACK, so we may want to have limitations on how much traffic can be sent until we receive a response from the server. Though the trickiness is that in TCP the server can always send a RST to tell the proxy to stop sending, and we don't have an equivalent in UDP.",
          "createdAt": "2020-10-09T20:21:32Z",
          "updatedAt": "2020-10-09T20:21:32Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "Upon further reflection, given a strong recommendation to not buffer datagrams at the proxy, the only performance issue I can see presupposes that we have two layers of congestion control, which is not a good presumption at this point.\r\n\r\nSo I agree that adding text discouraging buffering Datagrams for bursts will solve this issue.",
          "createdAt": "2020-10-09T21:01:18Z",
          "updatedAt": "2020-10-09T21:01:18Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "MDU6SXNzdWU3MTg0MjM4NTU=",
      "title": "Limit Packets before server response",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/11",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "@DavidSchinazi in #10 suggested I file this as a separate issue.\r\n\r\nThe anonymization properties of MASQUE make it a nice vector to send out large bursts of datagrams to unsuspecting targets. It would be wise for MASQUE proxies to implement some sort of hard limit on datagrams it's willing to transmit without hearing anything from the server.\r\n\r\nOf course, the client here is working harder than either the proxy or the server, but it would be bad to get the proxy IP on a denylist.",
      "createdAt": "2020-10-09T21:09:02Z",
      "updatedAt": "2020-10-09T21:09:02Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWU3MTg0MjYxMTY=",
      "title": "Nested Congestion Control",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/12",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This is a placeholder to discuss the effects/mitigations for nested congestion control, as required in the charter.",
      "createdAt": "2020-10-09T21:13:57Z",
      "updatedAt": "2020-10-12T18:10:49Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "Among the ugly issues here is that inner connection QUIC ACKs might be congestion controlled by the outer connection, and/or scheduled behind potentially large amounts of data on other streams.",
          "createdAt": "2020-10-09T21:16:58Z",
          "updatedAt": "2020-10-09T21:16:58Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "The way I think about this is that any router on the Internet implements a congestion controller. If we focus on a single direction of traffic, routers will have an input interface, and an output interface - if for some reason there are more packets coming into the input interface than the capacity of the output interface, then the router will have to exert control over that output link congestion, and its signaling mechanism is to drop some packets.\r\n\r\nWith that in mind, any TCP or QUIC connection going over the Internet has to deal with nested congestion controllers, and things work pretty decently. Going back to @martinduke's example from https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/12#issuecomment-706406176, any router can drop QUIC ACKs, and QUIC can handle that just fine.\r\n\r\nMy question is: how is a CONNECT-UDP proxy which can drop DATAGRAMs because of its congestion controller any different from a regular router than can drop packets due to its output link being saturated?\r\n\r\nTo clarify, I'm not suggesting we close this issue with no action - adding some notes explaining caveats sounds reasonable, but I don't see a need to develop an explicit solution to this problem.",
          "createdAt": "2020-10-10T21:12:54Z",
          "updatedAt": "2020-10-10T21:12:54Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "I don't think this is a question of correctness (it doesn't create infinite loops or deadlocks), but one of performance.\r\n\r\nWhile is some respects routers have \"congestion controllers\", they are generally not probing the path bandwidth or measuring latency, just looking at their local queue occupancy. Maybe your answer is to simply drop all datagrams for which there isn't immediately available cwnd; that may work, though we'd have to think about whether or not that's better than queueing them.\r\n\r\nIn QUIC we specifically exempted pure ACKs from congestion control because we were concerned about deadlocks, as congestion control could block sending ACKs that would unblock the connection. I don't think that's an issue here. But bad choices for the proxy scheduler could result in large delay spikes on these acks.\r\n\r\nI'll spend some time thinking about corner cases, but fundamentally I don't have a problem with your proposal to simply add some caveats.",
          "createdAt": "2020-10-12T18:06:13Z",
          "updatedAt": "2020-10-12T18:10:49Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "MDU6SXNzdWU3MTg0MjY3MzM=",
      "title": "Nested Loss Recovery",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/13",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This is a placeholder to discuss the effects/mitigations for nested loss recovery, as required in the charter. Of course, this only applies to MASQUE running over HTTP versions with no DATAGRAM frames.",
      "createdAt": "2020-10-09T21:15:17Z",
      "updatedAt": "2020-10-09T21:15:17Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": []
}