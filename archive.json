{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2020-09-22T00:51:26.460910+00:00",
  "repo": "ietf-wg-masque/draft-ietf-masque-connect-udp",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWU2ODc2OTQ1NTE=",
      "title": "CONNECT-UDP and multiple intermediaries",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/1",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue reported by @martinthomson on [2020-04-16](https://github.com/DavidSchinazi/masque-drafts/issues/21#issue-601716642)\r\n\r\n> Note that when multiple proxies are involved in a CONNECT-UDP request, all the HTTP connections along the path need to be using HTTP/3 [H3] or later in order for UDP payloads to be sent over QUIC DATAGRAM frames.\r\n\r\nHow is this true? The first proxy should convert the stream of encapsulated UDP datagrams into actual UDP datagrams. That means that the second proxy won't see these as part of the connection.\r\n\r\nThis is only an issue if the proxy wants to pass the DATAGRAM frames on to the next proxy. But that's not what is being asked of it, if it does that, it does so on its own recognizance. (I should add: if it chooses to forward to a next hop that uses h2, then it can take the DATAGRAM frames and stuff them into the request stream.)",
      "createdAt": "2020-08-28T04:03:10Z",
      "updatedAt": "2020-08-28T04:04:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Reply by me on 2020-04-17:\r\n\r\nIt's definitely possible for a chain of proxies to use heterogeneous encodings for their UDP packets, by which I mean if the topology is `Client - ProxyA - ProxyB - Destination` then we could build this so that `Client - ProxyA` uses DATAGRAM frames whereas `ProxyA - ProxyB` uses the stream encoding with HTTP/2.\r\n\r\nI don't think the benefits outweigh the added complexity, so the current design is all-or-nothing: if all legs supports H3-DATAGRAM then it can be used, otherwise fallback to the stream encoding.",
          "createdAt": "2020-08-28T04:03:51Z",
          "updatedAt": "2020-08-28T04:03:51Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Reply by @martinthomson on 2020-04-19:\r\n\r\nI'm not really clear on how you think that might work. If Client and Proxy A negotiate the use of DATAGRAM, does this depend on Proxy A verifying first that Proxy B also supports DATAGRAM? How do you ensure that the identifiers are comprehensible to all parties?",
          "createdAt": "2020-08-28T04:04:13Z",
          "updatedAt": "2020-08-28T04:04:13Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "MDU6SXNzdWU2ODc2OTUzMjM=",
      "title": "CONNECT-UDP request body",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/2",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue reported by @martinthomson on [2020-04-16](https://github.com/DavidSchinazi/masque-drafts/issues/22):\r\n\r\n>    A payload within a CONNECT-UDP request message has no defined semantics; a CONNECT-UDP request with a non-empty payload is malformed.\r\n\r\nI think that this text is out of sync with the rest of the doc.  The payload is used to carry UDP packets, even when you use DATAGRAM frames.",
      "createdAt": "2020-08-28T04:05:37Z",
      "updatedAt": "2020-08-28T04:06:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Reply from me on 2020-04-17:\r\n\r\nI think this is just a question of semantics. CONNECT takes over the stream, and therefore the contents of that stream are not considered to be the payload of the HTTP response.\r\n\r\nFrom [RFC 7231 s4.3.6](https://tools.ietf.org/html/rfc7231#section-4.3.6):\r\n>   A payload within a CONNECT request message has no defined semantics;\r\n>   sending a payload body on a CONNECT request might cause some existing\r\n>   implementations to reject the request.",
          "createdAt": "2020-08-28T04:06:03Z",
          "updatedAt": "2020-08-28T04:06:03Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU2ODc2OTU5NzU=",
      "title": "Datagram-Flow-Id is hop-by-hop",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/3",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue reported by @martinthomson on [2020-04-16](https://github.com/DavidSchinazi/masque-drafts/issues/23):\r\n\r\nThat is *probably* OK for something with CONNECT-like semantics, but we did explicitly choose to disable hop-by-hop fields in HTTP/2.",
      "createdAt": "2020-08-28T04:07:34Z",
      "updatedAt": "2020-08-28T04:08:43Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment from @martinthomson on 2020-04-16:\r\n\r\nI just realized that, because this is a new method and will be treated as such by intermediaries that don't understand it, they will pass Datagram-Flow-Id along. That is very much a bad thing as the server on the next hop might have negotiated H3_DATAGRAM with the intermediary for other reasons. If the next hop understands the setting, it might send responses in datagrams that will then be dropped by the intermediary (because it doesn't understand Datagram-Flow-Id).\r\n\r\nThat is, on a chain of entities from client A, intermediary B, and intermediary C, if all of them support H3_DATAGRAM, but B does not support Datagram-Flow-Id or CONNECT-UDP, this ultimately results in packets being sent on the request stream for a while, then DATAGRAM frames being sent toward the intermediary and being dropped.",
          "createdAt": "2020-08-28T04:07:56Z",
          "updatedAt": "2020-08-28T04:07:56Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment from me on 2020-04-17:\r\n\r\nRegarding your first comment, I agree that this is somewhat of a hop-by-hop field. Do you have a proposal that achieves the same result without using a hop-by-hop field?\r\n\r\nRegarding your second comment, it's not possible for intermediaries to not understand this and still pass it along. If the intermediary doesn't know about this spec it'll respond with status code 405 \"Method Not Allowed\" instead of forwarding it.",
          "createdAt": "2020-08-28T04:08:11Z",
          "updatedAt": "2020-08-28T04:08:11Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment from @martinthomson on 2020-04-19:\r\n\r\nProxies aren't required to understand all methods, so why would it send a 405? I mean, some might because they want to police what methods they pass, but they are not required to do so.",
          "createdAt": "2020-08-28T04:08:26Z",
          "updatedAt": "2020-08-28T04:08:26Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment from me on 2020-07-24:\r\n\r\nSorry, I should have said 501 \"Not Implemented\", not 405.",
          "createdAt": "2020-08-28T04:08:43Z",
          "updatedAt": "2020-08-28T04:08:43Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU2ODc2OTY3OTg=",
      "title": "Flow duration",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/4",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue created by @martinthomson on [2020-04-16](https://github.com/DavidSchinazi/masque-drafts/issues/24):\r\n\r\nThe CONNECT-UDP proxy has to act a little like a NAT when it forwards UDP. It has to assign a source IP and port. Those probably need to be dedicated to the flow for its lifetime. However, UDP lacks the clear signals of TCP about connection termination, so we need a clear definition of what lifetime is.\r\n\r\nIt is perhaps reasonable to tie the lifetime of the allocation to the existence of the stream, but then the connection from the client might drop mid-flow; how long does the proxy need to avoid reusing that address?\r\n\r\nThe proxy might also decide that idleness is cause for dropping bindings. The client needs to know this because it will need to make new tunnels to continue communication if it goes idle for too long.",
      "createdAt": "2020-08-28T04:10:04Z",
      "updatedAt": "2020-08-28T18:11:57Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment from me on 2020-04-17:\r\n\r\nThe intent was to have the lifetime of the UDP socket be tied to the existence of the CONNECT-UDP stream. But I agree that we should add text indicating that a server MAY want to garbage collect these after idle periods, and in that case it MUST close the corresponding stream to inform the client.",
          "createdAt": "2020-08-28T04:10:18Z",
          "updatedAt": "2020-08-28T04:10:18Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "An interesting extension: retain the binding for N seconds after the connection to the proxy drops and allow the client to rebind to that.  That allows for session continuity across transient connection failures for protocols that aren't QUIC (which are less vulnerable to that).",
          "createdAt": "2020-08-28T06:50:26Z",
          "updatedAt": "2020-08-28T06:50:26Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "That's a good idea. I could totally imagine an extension where the proxy tells the client the outgoing port it used in its CONNECT-UDP reply, and then the client is allowed to ask for a preferred port when requesting CONNECT-UDP. This could be achieved via HTTP request/response headers.",
          "createdAt": "2020-08-28T18:11:56Z",
          "updatedAt": "2020-08-28T18:11:56Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU2ODc2OTc0MDY=",
      "title": "Address mapping and return flow routing",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/5",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue created by @martinthomson on [2020-04-16](https://github.com/DavidSchinazi/masque-drafts/issues/25):\r\n\r\nThe design here would appear to permit the use of 'Address and Port-Dependent Mapping' as defined in [Section 4.1 of RFC 4787](https://tools.ietf.org/html/rfc4787#section-4.1).  However, that document strongly recommends that an 'Endpoint-Independent Mapping' is used so as to make UNSAF methods work.  This document should define those rules.\r\n\r\nRelated #4.",
      "createdAt": "2020-08-28T04:11:51Z",
      "updatedAt": "2020-08-28T04:12:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment from me on 2020-04-17:\r\n\r\nThe current text explicitly only allows \"Address and Port-Dependent Mapping\". It attempted to define those rules clearly in [section 6](https://tools.ietf.org/html/draft-schinazi-masque-connect-udp-00#section-6). UNSAF is currently considered out of scope and not supported. I'm not sure whether we want to increase the scope and add that complexity.",
          "createdAt": "2020-08-28T04:12:07Z",
          "updatedAt": "2020-08-28T04:12:07Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU2ODc2OTc4OTE=",
      "title": "Datagram-Flow-Id size limits",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/6",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue created by me on [2020-05-05](https://github.com/DavidSchinazi/masque-drafts/issues/26):\r\n\r\nAs of `connect-udp-00`, the `Datagram-Flow-Id` is [defined](https://tools.ietf.org/html/draft-schinazi-masque-connect-udp-00#section-5) as a [structured header of type sh-integer](https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-18#section-3.3.1). The max value for those is 10^15-1, but in theory flow IDs can go up to 2^62-1 (~4*10^18). We should either:\r\n- specify an alternate encoding, such as [an sh-binary byte sequence with specified endianness and maximum width](https://lists.w3.org/Archives/Public/ietf-http-wg/2020AprJun/0077.html)\r\n- note that values over 10^15-1 cannot be encoded and reaching that flow identifier should trigger closing the HTTP/3 connection and restarting it",
      "createdAt": "2020-08-28T04:13:18Z",
      "updatedAt": "2020-08-28T04:13:51Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment by @LPardue on 2020-05-05:\r\n\r\nI think the lower limit is ok. As a tangent, it might play nice with H2 fallback that uses stream IDs which are restricted to 2^31",
          "createdAt": "2020-08-28T04:13:50Z",
          "updatedAt": "2020-08-28T04:13:50Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWU2ODc2OTgzNzg=",
      "title": "CONNECT-UDP should communicate MTU",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/7",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue created by me on [2020-05-27](https://github.com/DavidSchinazi/masque-drafts/issues/27):\r\n\r\nCONNECT-UDP can be used across multiple proxy hops, and each of these hops can have a different MTU, so it could be useful for the client to be notified of the maximum DATAGRAM payload size that will make it across all the hops. This value could also change over time, so we could consider adding the ability to communicate that.",
      "createdAt": "2020-08-28T04:14:55Z",
      "updatedAt": "2020-08-28T04:15:11Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment from me on 2020-07-24:\r\n\r\nThis might be best handled by an extension to CONNECT-UDP, but keeping the issue open for now.",
          "createdAt": "2020-08-28T04:15:11Z",
          "updatedAt": "2020-08-28T04:15:11Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWU2ODc2OTg4Mjg=",
      "title": "CONNECT-UDP needs a request target URI",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/8",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue created by me on [2020-08-13](https://github.com/DavidSchinazi/masque-drafts/issues/29):\r\n\r\n[connect-udp-00 s3](https://tools.ietf.org/html/draft-schinazi-masque-connect-udp-00#section-3) mainly copied most of the CONNECT-UDP design from CONNECT, but than goes against some existing HTTP semantics. In particular, every HTTP method is supposed to use URIs to represent their request target (this was mentioned in [RFC 7231 s2](https://tools.ietf.org/html/rfc7231#section-2) and clarified in [draft-ietf-httpbis-semantics s6.1](https://tools.ietf.org/html/draft-ietf-httpbis-semantics-10#section-6.1)). CONNECT and OPTIONS are noted as existing exceptions, but new methods are not allowed exceptions, to allow intermediaries to proxy unknown methods. CONNECT-UDP only cares about the authority (host and port) portion of the URI, so we can easily encode that as an URI and mandate that the path MUST be \"/\" and the query MUST be empty. The main open question is what scheme to use. We could either reuse https, or register a new one.",
      "createdAt": "2020-08-28T04:16:15Z",
      "updatedAt": "2020-08-28T04:17:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment by @mirjak on 2020-08-14:\r\n\r\ndraft-ietf-httpbis-semantics notes CONNECT as a special case because it's only used for tunnelling by proxies and usually not even implemented by the origin server. This is the same scenario as we have for any new connect method and I think we should therefore follow the same semantics as already defined for CONNECT.",
          "createdAt": "2020-08-28T04:16:39Z",
          "updatedAt": "2020-08-28T04:16:39Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment by @MikeBishop on 2020-08-14:\r\n\r\n`udp://target-host:port`?",
          "createdAt": "2020-08-28T04:17:13Z",
          "updatedAt": "2020-08-28T04:17:13Z"
        }
      ]
    }
  ],
  "pulls": []
}